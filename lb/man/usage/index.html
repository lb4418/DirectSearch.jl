<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · DirectSearch.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DirectSearch.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li><a class="tocitem" href="#Problem-Specification"><span>Problem Specification</span></a></li><li><a class="tocitem" href="#Constraints"><span>Constraints</span></a></li><li><a class="tocitem" href="#Method-Choice"><span>Method Choice</span></a></li><li><a class="tocitem" href="#Custom-Algorithms"><span>Custom Algorithms</span></a></li></ul></li><li><a class="tocitem" href="../addstoppingconditions/">Stopping Conditions</a></li><li><a class="tocitem" href="../reporting/">Reporting</a></li><li><a class="tocitem" href="../addsearch/">Adding a Search Step</a></li><li><a class="tocitem" href="../addpoll/">Adding a Poll Step</a></li><li><a class="tocitem" href="../cache/">Cache</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../ref/public/">Public API</a></li><li><a class="tocitem" href="../../ref/internal/">Internal</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lb4418/DirectSearch.jl/blob/master/docs/src/man/usage.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><p>DirectSearch.jl provides a framework for the implementation of direct search algorithms, currently focusing on the Mesh Adaptive Direct Search (MADS) family. These are derivative free, black box algorithms, meaning that no analytical knowledge of the objective function or any constraints are needed. This package provides the core MADS algorithms (LTMADS, OrthoMADS, granular variables and dynamic scaling, as well as progressive and extreme barrier constraints), and is designed to allow custom algorithms to be easily added.</p><h2 id="Problem-Specification"><a class="docs-heading-anchor" href="#Problem-Specification">Problem Specification</a><a id="Problem-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Specification" title="Permalink"></a></h2><p>The core data structure is the <code>DSProblem</code> type. At a minimum it requires the dimension of the problem:</p><pre><code class="language-julia">p = DSProblem(3);</code></pre><p>The objective function, initial point, and other parameters may be specified in <code>DSProblem</code>:</p><pre><code class="language-julia">obj(x) = x&#39;*[2 1;1 4]*x + x&#39;*[1;4] + 7;
p = DSProblem(2; objective=obj, initial_point=[1.0,2.0]);</code></pre><p>Note that the objective function is assumed to take a vector of points of points as the input, and return a scalar cost. The initial point should be an array of the same dimensions of the problem, and feasible with respect to any extreme barrier constraints. See <code>DSProblem</code>&#39;s documentation for a full list of parameters.</p><p>Parameters can also be set after generation of the problem:</p><pre><code class="language-julia">p = DSProblem(2)
SetInitialPoint(p, [1.0,2.0])
SetObjective(p,obj)
SetIterationLimit(p, 500)</code></pre><h3 id="Variable-Bounds"><a class="docs-heading-anchor" href="#Variable-Bounds">Variable Bounds</a><a id="Variable-Bounds-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Bounds" title="Permalink"></a></h3><p>The bounds of problem variables can be set with <code>SetVariableRange</code> or <code>SetVariableRanges</code>. These values are used to set the initial poll sizes of each variable. By default the variables are defined as unbounded.</p><p>If a bound for a single variable is required to be defined, it can be set with <code>SetVariableRange</code>. <code>i</code> is the index of the variable, and the following numbers are the upper and lower bound of the variable respectively.</p><pre><code class="language-julia">SetVariableRange(p, i, 10000, 20000)</code></pre><p>The same operation can be applied to all variables with <code>SetVariableRanges</code> (example for N=3):</p><pre><code class="language-julia">SetVariableRanges(p, [10000, -5, -10000], [20000, 5, 10000])</code></pre><p>Be aware that this <strong>does not</strong> add a constraint on the variable, it <strong>only</strong> gives additional information when defining the initial poll size, which acts as the initial scaling of the variables. Constraints on variable range should be added explicitly as constraints.</p><h3 id="Granular-Variables"><a class="docs-heading-anchor" href="#Granular-Variables">Granular Variables</a><a id="Granular-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Granular-Variables" title="Permalink"></a></h3><p>If variables other than continuous, such as integers, are desired to be used, this can be specified through the granularity of the problem variables. The granularity is taken to be 0 for continuous variables and 1 for integers. The granularity can be any non-negative value.</p><p>If the granularity for a single variable is required to be defined, it can be set with <code>SetGranularity</code>. <code>i</code> is the index of the variable, and the following number is the granularity.</p><pre><code class="language-julia">SetGranularity(p, i, 0.1)</code></pre><p>The same operation can be applied to all variables with <code>SetGranularities</code> (example for N=3):</p><pre><code class="language-julia">SetGranularities(p, [1.0, 0.1, 0.01])</code></pre><h3 id="Optimizing"><a class="docs-heading-anchor" href="#Optimizing">Optimizing</a><a id="Optimizing-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing" title="Permalink"></a></h3><p>Run the algorithm with <code>Optimize!</code>.</p><pre><code class="language-julia">Optimize!(p)</code></pre><p>This will run MADS until one of the defined stopping conditions is met. By default, the stopping conditions are set to the iteration limit (default 1000), function evaluation limit (default 5000), mesh precision limit (<code>Float64</code> precision) and poll precision limit (<code>Float64</code> precision). For more detail on stopping conditions, and how to define a custom one see <a href="../addstoppingconditions/#Adding-Stopping-Conditions">Adding Stopping Conditions</a>.</p><p>After optimization is finished, the detailed results are printed as in the following example:</p><pre><code class="nohighlight">==================================================
MADS Run Summary
--------------------------------------------------
Feasible Solution           [1.0005, 10.0]
Feasible Cost               0.0
Infeasible Solution         nothing
Infeasible Cost             nothing

Iterations                  52
Function Evaluations        196
Cache hits                  13
Optimization Status         Mesh Precision limit

Runtime                     0.9472651481628418
Search Time                 4.499999999999997e-6
Poll Time                   0.4502825000000001
Blackbox Evaluation Time    0.00048089999999999917</code></pre><h3 id="Type-Parameterisation"><a class="docs-heading-anchor" href="#Type-Parameterisation">Type Parameterisation</a><a id="Type-Parameterisation-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Parameterisation" title="Permalink"></a></h3><p>By default, <code>DSProblem</code> is parameterised as <code>Float64</code>, but this can be overridden:</p><pre><code class="language-julia">p = DSProblem{Float32}(3);</code></pre><p>However, this is mostly untested and will almost certainly break. It is included to allow future customisation to be less painful.</p><h3 id="Parallel-Blackbox-Evaluations"><a class="docs-heading-anchor" href="#Parallel-Blackbox-Evaluations">Parallel Blackbox Evaluations</a><a id="Parallel-Blackbox-Evaluations-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Blackbox-Evaluations" title="Permalink"></a></h3><p>If Julia was started with more than one thread using the option <span>$--threads N$</span> where <code>N</code> is the number of threads, then DirectSearch.jl can be configured to evaluate the objective functions in parallel using multiple threads. This can done by calling the function <span>$SetMaxEvals$</span>:</p><pre><code class="language-julia">SetMaxEvals(p)</code></pre><p>Note that using multiple threads is only beneficial when the function to evaluate takes a long time using a single thread (1ms or more). Otherwise, the runtime will increase due to multi-threading overheads.</p><h2 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h2><p>Two kinds of constraints are included, progressive barrier, and extreme barrier constraints. As with the objective function, these should be specified as a Julia function that takes a vector, and returns a value. </p><h3 id="Extreme-Barrier-Constraints"><a class="docs-heading-anchor" href="#Extreme-Barrier-Constraints">Extreme Barrier Constraints</a><a id="Extreme-Barrier-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Extreme-Barrier-Constraints" title="Permalink"></a></h3><p>Extreme barrier constraints are constraints that cannot be violated, and their function should return boolean (true for a feasible point, false for infeasible), or a numerical value giving the constraint violation amount (≤0 for feasible, &gt;0 for infeasible). Added with <code>AddExtremeConstraint</code>:</p><pre><code class="language-julia">cons(x) = x[1] &gt; 0 #Constrains x[1] to be larger than 0
AddExtremeConstraint(p, cons)</code></pre><h3 id="Progressive-Barrier-Constraints"><a class="docs-heading-anchor" href="#Progressive-Barrier-Constraints">Progressive Barrier Constraints</a><a id="Progressive-Barrier-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Progressive-Barrier-Constraints" title="Permalink"></a></h3><p>Progressive barrier constraints may be violated, transforming the optimization into a dual-objective form that attempts to decrease the amount that the constraint is violated by. Functions that implement a progressive barrier constraint should take a point input and return a numerical value that indicates the constraint violation amount (≤0 for feasible, &gt;0 for infeasible). Added via <code>AddProgressiveConstraint</code>:</p><pre><code class="language-julia">cons(x) = x[1] #Constraints x[1] to be less than or equal to 0
AddProgressiveConstraint(p, cons)</code></pre><h3 id="Equality-Constraints"><a class="docs-heading-anchor" href="#Equality-Constraints">Equality Constraints</a><a id="Equality-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Equality-Constraints" title="Permalink"></a></h3><p>The package does not care about the form of constraints (as they are treated like a black box). However in many cases, the algorithm will not be able to generate trial points that are exactly able to satisfy equality constraints. </p><p>Therefore, to implement extreme barrier equality constraints a tolerance should be included in the constraint function. Alternatively progressive barrier constraints can be used, but it is likely that the algorithm will not be able to generate feasible solutions, but the final point should be very close to feasible.</p><h3 id="Constraint-Indexes"><a class="docs-heading-anchor" href="#Constraint-Indexes">Constraint Indexes</a><a id="Constraint-Indexes-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-Indexes" title="Permalink"></a></h3><p>The functions to add a constraint return an index that can be used to refer to the constraints for modification. When supplied with a vector of functions both constraint functions will return a vector of indexes.</p><p>Currently these indexes have no direct use. But functions to ignore constraints will be added in future.</p><h3 id="Collections"><a class="docs-heading-anchor" href="#Collections">Collections</a><a id="Collections-1"></a><a class="docs-heading-anchor-permalink" href="#Collections" title="Permalink"></a></h3><p>Constraints are stored in data structures named &#39;Collections&#39;. Each collection can contain any number of constraints of the same type. By default, extreme barrier constraints are stored in collection one, and progressive barrier constraints in collection two. In most cases, collections can be ignored.</p><p>New collections can be created with the following functions:</p><pre><code class="language-julia">AddProgressiveCollection(p);
AddExtremeCollection(p);</code></pre><p>The collection contains configuration options for the constraints within it. For example, by default the progressive barrier collection uses a square norm when summing constraint violation, this can be configured to use an alternate norm by defining a new collection. See the documentation for the individual functions for all the possible configuration options.</p><p>As with adding individual constraints, collections return an index. This is useful for specifying a collection to add a constraint to. These indexes will also be used to refer to the collections for modification in future. </p><h2 id="Method-Choice"><a class="docs-heading-anchor" href="#Method-Choice">Method Choice</a><a id="Method-Choice-1"></a><a class="docs-heading-anchor-permalink" href="#Method-Choice" title="Permalink"></a></h2><p>MADS defines two stages in each iteration: search and poll. </p><h3 id="Search"><a class="docs-heading-anchor" href="#Search">Search</a><a id="Search-1"></a><a class="docs-heading-anchor-permalink" href="#Search" title="Permalink"></a></h3><p>The search stage employs an arbitrary strategy to look for an improved point in the current mesh. This can be designed to take advantage of a known property of the objective function&#39;s structure, or be something generic, for example, a random search, or ignored. </p><p>A search step returns a set of points that are then evaluated on the objective function.</p><p>The choice of search strategy is set in <code>DSProblem</code>:</p><pre><code class="language-julia">p = DSProblem(3; search=RandomSearch(10))</code></pre><p>The current included search strategies are <code>NullSearch</code> and <code>RandomSearch</code>. <code>NullSearch</code> will perform no search stage and is the default choice. <code>RandomSearch</code> will select M random points on the current mesh, where M is the option given to it when instantiated.</p><h3 id="Poll"><a class="docs-heading-anchor" href="#Poll">Poll</a><a id="Poll-1"></a><a class="docs-heading-anchor-permalink" href="#Poll" title="Permalink"></a></h3><p>The poll step is a more rigorously defined exploration in the local space around the incumbent point.</p><p>Poll steps return a set of directions that are then evaluated with a preset distance value.</p><p>As with the search step, it is set in <code>DSProblem</code>:</p><pre><code class="language-julia">p = DSProblem(3; poll=LTMADS())
p = DSProblem(3; poll=OrthoMADS())</code></pre><p>Two poll steps are included. The first is LTMADS, which generates a set of directions from a basis generated from a semi-random lower triangular matrix. The other is OrthoMADS, a later algorithm that generates an orthogonal set of directions. It was recently adapted to granular variables as in 2019 C. Audet, S. Le Digabel, and C. Tribes, but the same name is continued to be used. By default, LTMADS is used.</p><p>Both OrthoMADS and LTMADS are non-deterministic, and will therefore give different results every time they are run. For this reason, they may need several runs to achieve their best results.</p><h2 id="Custom-Algorithms"><a class="docs-heading-anchor" href="#Custom-Algorithms">Custom Algorithms</a><a id="Custom-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Algorithms" title="Permalink"></a></h2><p>DirectSearch.jl is designed to make it simple to add custom search and poll stages. See <a href="../addsearch/#Adding-a-Search-Step">Adding a Search Step</a> and <a href="../addpoll/#Adding-a-Poll-Step">Adding a Poll Step</a> for an overview of this.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../addstoppingconditions/">Stopping Conditions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 15 June 2021 16:51">Tuesday 15 June 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
